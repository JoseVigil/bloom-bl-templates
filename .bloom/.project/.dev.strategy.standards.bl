# .project/.dev.strategy.standards.bl

## PROPÓSITO
Define cómo debe escribirse el código del proyecto a nivel estándar técnico.

---

## 1. ESTILO GLOBAL DEL PROYECTO

### 1.1 Indentación
- **Espacios**: [especificar: 2, 4, tab]
- **Consistencia**: No mezclar espacios y tabs.

### 1.2 Nomenclatura

**Variables**:
- [snake_case / camelCase]
- Ejemplos: `user_id`, `total_amount` o `userId`, `totalAmount`

**Funciones**:
- [snake_case / camelCase]
- Ejemplos: `get_user()`, `calculate_total()` o `getUser()`, `calculateTotal()`

**Clases**:
- PascalCase
- Ejemplos: `UserService`, `OrderController`

**Constantes**:
- UPPER_SNAKE_CASE
- Ejemplos: `MAX_RETRIES`, `API_TIMEOUT`

**Archivos**:
- [kebab-case / snake_case]
- Ejemplos: `user-service.js`, `order-controller.py` o `user_service.js`, `order_controller.py`

### 1.3 Longitud de línea
- Máximo [80 / 100 / 120] caracteres por línea.
- Romper líneas largas con indentación lógica.

### 1.4 Espacios en blanco
- Una línea en blanco entre funciones.
- Dos líneas en blanco entre clases (si el lenguaje lo permite).
- No dejar espacios al final de las líneas.

---

## 2. MODULARIZACIÓN

### 2.1 Principio de responsabilidad única
- Cada módulo/clase/función debe tener una única responsabilidad.
- Si una función hace más de una cosa, dividirla.

### 2.2 Tamaño de archivos
- **Archivos pequeños**: <200 líneas (ideal).
- **Archivos medianos**: 200-500 líneas (aceptable).
- **Archivos grandes**: >500 líneas (requiere justificación).

**Regla obligatoria**: Si un archivo supera las 500 líneas, considerar dividirlo en módulos más pequeños.

### 2.3 Organización de imports

**Orden**:
1. Librerías estándar del lenguaje.
2. Librerías de terceros.
3. Módulos internos del proyecto.

**Ejemplo (Python)**:
```python
# Estándar
import os
import sys

# Terceros
import requests
from flask import Flask

# Internos
from app.services import UserService
from app.models import User
```

---

## 3. COMENTARIOS Y DOCUMENTACIÓN

### 3.1 Comentarios en código

**Qué comentar**:
- Decisiones de diseño no obvias.
- "Por qué" se hizo algo, no "qué" hace el código.
- Workarounds temporales o limitaciones conocidas.

**Qué NO comentar**:
- Código obvio que se explica a sí mismo.
- Código comentado (eliminarlo o justificar por qué está).

### 3.2 Docstrings (si el lenguaje lo permite)

**Módulos**:
```python
"""
Módulo de autenticación de usuarios.

Proporciona funciones para login, logout y validación de tokens.
"""
```

**Funciones**:
```python
def authenticate(username: str, password: str) -> bool:
    """
    Autentica un usuario con sus credenciales.
    
    Args:
        username: Nombre de usuario
        password: Contraseña en texto plano
        
    Returns:
        True si la autenticación es exitosa, False en caso contrario
        
    Raises:
        ValueError: Si username o password están vacíos
    """
    pass
```

---

## 4. MANEJO DE ERRORES

### 4.1 Excepciones específicas
- Capturar excepciones específicas, no genéricas.
- No usar `except Exception` sin justificación.

**Ejemplo**:
```python
# ❌ Malo
try:
    result = risky_operation()
except:
    pass

# ✅ Bueno
try:
    result = risky_operation()
except ValueError as e:
    logger.error(f"Error de validación: {e}")
    raise
```

### 4.2 Logging
- Usar niveles apropiados: DEBUG, INFO, WARNING, ERROR, CRITICAL.
- No hacer logging de información sensible (passwords, tokens).

---

## 5. TESTS (SI APLICA)

### 5.1 Cobertura
- Mínimo [especificar: 70%, 80%, no definido] de cobertura.
- Tests obligatorios para lógica crítica.

### 5.2 Nomenclatura
- Nombre de archivo: `test_<nombre_modulo>.py` o `<nombre_modulo>.test.js`.
- Nombre de función: `test_<comportamiento_esperado>`.

**Ejemplo**:
```python
def test_authenticate_valid_credentials_returns_true():
    assert authenticate("user", "pass") == True

def test_authenticate_invalid_credentials_returns_false():
    assert authenticate("user", "wrong") == False
```

### 5.3 Estructura de tests
- **Arrange**: Configurar el estado inicial.
- **Act**: Ejecutar la acción.
- **Assert**: Verificar el resultado.

---

## 6. SEGURIDAD

### 6.1 Credenciales
- Nunca hardcodear credenciales en el código.
- Usar variables de entorno o sistemas de secretos.

### 6.2 Validación de inputs
- Validar todo input externo.
- Sanitizar datos antes de usarlos en queries o comandos.

### 6.3 Autenticación y autorización
- Implementar autenticación en endpoints protegidos.
- Verificar permisos antes de ejecutar operaciones críticas.

---

## 7. PERFORMANCE

### 7.1 Optimización prematura
- No optimizar sin medir primero.
- Priorizar legibilidad sobre micro-optimizaciones.

### 7.2 Caché
- Cachear datos que no cambian frecuentemente.
- Invalidar caché cuando corresponda.

### 7.3 Queries de base de datos
- Evitar N+1 queries.
- Usar índices en columnas frecuentemente consultadas.
- Limitar resultados con paginación.

---

## 8. VERSIONADO

### 8.1 Commits
- Mensajes descriptivos.
- Formato: `[tipo]: descripción breve`.
- Tipos: `feat`, `fix`, `refactor`, `docs`, `test`, `chore`.

**Ejemplo**:
```
feat: agregar autenticación con OAuth
fix: corregir validación de email
refactor: extraer lógica de pago a servicio separado
```

### 8.2 Branches
- `main` o `master`: código en producción.
- `develop`: código en desarrollo.
- `feature/<nombre>`: nuevas funcionalidades.
- `fix/<nombre>`: correcciones de bugs.

---

## 9. REFACTORIZACIÓN

### 9.1 Cuándo refactorizar
- Código duplicado.
- Funciones demasiado largas (>50 líneas).
- Nombres confusos o inconsistentes.
- Complejidad ciclomática alta.

### 9.2 Cómo refactorizar
- Hacer cambios incrementales.
- Ejecutar tests después de cada cambio.
- No cambiar comportamiento, solo estructura.

---

## 10. ENCAPSULACIÓN Y BOUNDARIES

### 10.1 Visibilidad
- Hacer privado todo lo que no necesite ser público.
- Usar convenciones del lenguaje para indicar privacidad:
  - Python: `_private_method()`
  - JavaScript: `#privateField`

### 10.2 Interfaces públicas
- Definir claramente qué es público y qué es privado.
- No exponer detalles de implementación.

### 10.3 Dependencias
- Invertir dependencias cuando sea necesario (Dependency Inversion).
- Usar inyección de dependencias para facilitar testing.

---

## 11. VERIFICACIÓN FINAL

Antes de entregar código, confirma:

- ✅ El código sigue las convenciones de nomenclatura.
- ✅ La indentación es consistente.
- ✅ Los imports están ordenados correctamente.
- ✅ Los comentarios explican "por qué", no "qué".
- ✅ Las excepciones son específicas.
- ✅ No hay credenciales hardcodeadas.
- ✅ Los tests cubren la lógica crítica (si aplica).
- ✅ El código es legible y mantenible.

---

**FIN DE ESTÁNDARES TÉCNICOS DEL PROYECTO**